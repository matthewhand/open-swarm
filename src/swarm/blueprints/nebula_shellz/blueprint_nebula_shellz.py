import asyncio
import logging
import subprocess
import sys
from typing import Any, ClassVar

try:
    import time

    from agents import Agent, function_tool
    from agents.mcp import MCPServer
    from agents.models.interface import Model
    from rich.panel import Panel  # Import Panel for splash screen

    from swarm.core.blueprint_base import BlueprintBase
    from swarm.core.blueprint_ux import BlueprintUXImproved
except ImportError as e:
    print(f"ERROR: Import failed in nebula_shellz: {e}. Ensure 'openai-agents' install and structure.")
    print(f"sys.path: {sys.path}")
    sys.exit(1)

logger = logging.getLogger(__name__)

# --- Tool Definitions (Unchanged) ---
@function_tool
async def code_review(code_snippet: str) -> str:
    """Performs a comprehensive review of the provided code snippet, with enhanced TODO detection."""
    logger.info(f"Reviewing code snippet: {code_snippet[:50]}...")
    await asyncio.sleep(0.1)

    issues = []

    # Enhanced TODO detection - find all TODO comments and their context
    lines = code_snippet.splitlines()
    todo_lines = []
    for i, line in enumerate(lines, 1):
        if "TODO" in line.upper():
            # Get context around the TODO
            start = max(0, i-2)
            end = min(len(lines), i+2)
            context = "\n".join(lines[start:end])
            todo_lines.append(f"Line {i}: {line.strip()}\nContext:\n{context}")
            issues.append(f"TODO found on line {i}: {line.strip()}")

    # Additional code quality checks
    if len(lines) > 100:
        issues.append("Code is quite long - consider breaking into smaller functions")

    if "print(" in code_snippet and "logger" not in code_snippet:
        issues.append("Using print statements - consider using proper logging")

    # Check for unused imports (basic heuristic)
    [line.lower() for line in lines]
    if "import" in code_snippet and "unused" not in " ".join(issues).lower():
        import_count = sum(1 for line in lines if "import" in line)
        if import_count > len(lines) * 0.1:  # More than 10% import statements
            issues.append("Many import statements - check for unused imports")

    if issues:
        review_result = "Code Review Results:\n" + "\n".join(issues[:5])  # Limit to top 5 issues
        if len(issues) > 5:
            review_result += f"\n... and {len(issues)-5} more issues"
        if todo_lines:
            review_result += "\n\nDetailed TODO Analysis:\n" + "\n\n".join(todo_lines[:3])
        return review_result
    else:
        return "Code looks good! No major issues detected. âœ¨"
@function_tool
def generate_documentation(code_snippet: str) -> str:
    """Generates comprehensive JSDoc-style documentation for the provided code snippet."""
    logger.info(f"Generating documentation for: {code_snippet[:50]}...")

    lines = code_snippet.splitlines()
    first_line = lines[0] if lines else "N/A"

    # Extract function name if it's a function definition
    function_name = "unknown_function"
    if "def " in first_line:
        function_name = first_line.split("def ")[1].split("(")[0].strip()
    elif "function " in first_line:
        function_name = first_line.split("function ")[1].split("(")[0].strip()

    # Analyze parameters from function signature
    params = []
    if "(" in first_line and ")" in first_line:
        param_section = first_line.split("(")[1].split(")")[0]
        params = [p.strip() for p in param_section.split(",") if p.strip()]

    # Generate comprehensive JSDoc
    doc = "/**\n"
    doc += f" * {function_name.title()} - Enhanced documentation generator\n"
    doc += " * \n"
    doc += f" * @description Automatically generated documentation for the {function_name} function.\n"
    doc += f" * This function {'takes parameters' if params else 'does not take parameters'} and performs code analysis.\n"

    if params:
        doc += " * \n"
        doc += f" * @param {{string}} {' '.join([f'{p}_description' for p in params])} - {' '.join([f'Description for {p}' for p in params])}\n"

    doc += " * @returns {string} Detailed code review and analysis results\n"
    doc += " * @example\n"
    doc += " * ```javascript\n"
    doc += f" * const result = {function_name}('sample code');\n"
    doc += " * console.log(result); // Enhanced documentation output\n"
    doc += " * ```\n"
    doc += " * \n"
    doc += " * @author Auto-generated by NebulaShellzzar Documentation Tool\n"
    doc += " * @version 2.0 - Enhanced with parameter analysis and examples\n"
    doc += " * @since 2025-01-01\n"
    doc += " */\n"

    # Add implementation details
    doc += f"\n# Implementation Details for {function_name}\n"
    doc += "# \n"
    doc += "# This documentation was generated by analyzing:\n"
    doc += f"# - Function signature: {first_line}\n"
    doc += f"# - Total lines of code: {len(lines)}\n"
    if "TODO" in code_snippet:
        doc += f"# - TODO comments found: {'Yes' if 'TODO' in code_snippet else 'No'}\n"

    logger.debug(f"Generated comprehensive documentation:\n{doc}")
    return doc
def _execute_shell_command_raw(command: str) -> str:
    """Internal helper to execute a shell command. Separated for testability."""
    logger.info(f"Executing shell command: {command}")
    if not command:
        logger.warning("execute_shell_command called with empty command.")
        return "Error: No command provided."
    try:
        import os
        timeout = int(os.getenv("SWARM_COMMAND_TIMEOUT", "60"))
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout,
            check=False,
            shell=True,
        )
        output = (
            f"Exit Code: {result.returncode}\n"
            f"STDOUT:\n{result.stdout.strip()}\n"
            f"STDERR:\n{result.stderr.strip()}"
        )
        logger.debug(f"Command '{command}' result:\n{output}")
        return output
    except FileNotFoundError:
        cmd_base = command.split()[0] if command else ""
        logger.error(f"Command not found: {cmd_base}")
        return f"Error: Command not found - {cmd_base}"
    except subprocess.TimeoutExpired:
        import os as _os
        logger.error(f"Command '{command}' timed out after configured timeout.")
        return f"Error: Command '{command}' timed out after {_os.getenv('SWARM_COMMAND_TIMEOUT', '60')} seconds."
    except Exception as e:
        logger.error(
            f"Error executing command '{command}': {e}",
            exc_info=logger.level <= logging.DEBUG,
        )
        return f"Error executing command: {e}"


@function_tool
def execute_shell_command(command: str) -> str:
    """Executes a shell command and returns its stdout and stderr. Timeout is configurable via SWARM_COMMAND_TIMEOUT (default: 60s)."""
    return _execute_shell_command_raw(command)

# --- Agent Definitions (Instructions remain the same) ---
morpheus_instructions = """
You are Morpheus, the leader... (Instructions as before) ...
"""
trinity_instructions = """
You are Trinity, the investigator... (Instructions as before) ...
"""
neo_instructions = """
You are Neo, the programmer... (Instructions as before) ...
"""
oracle_instructions = "You are the Oracle..."
cypher_instructions = "You are Cypher..."
tank_instructions = "You are Tank..."

# --- Blueprint Definition ---
import random
import time

from rich.console import Console
from rich.live import Live
from rich.panel import Panel
from rich.text import Text


class NebuchaShellzzarBlueprint(BlueprintBase):
    """A multi-agent blueprint inspired by The Matrix for sysadmin and coding tasks."""
    metadata: ClassVar[dict[str, Any]] = {
        "name": "NebulaShellzzarBlueprint", "title": "NebulaShellzzar",
        "description": "A multi-agent blueprint inspired by The Matrix for system administration and coding tasks.",
        "version": "1.0.0", "author": "Open Swarm Team",
        "tags": ["matrix", "multi-agent", "shell", "coding", "mcp"],
        "required_mcp_servers": ["memory"],
    }
    _model_instance_cache: dict[str, Model] = {}

    def __init__(self, blueprint_id: str = "nebula_shellzzar", config=None, config_path=None, **kwargs):
        super().__init__(blueprint_id=blueprint_id, config=config, config_path=config_path, **kwargs)
        self.blueprint_id = blueprint_id
        self.config_path = config_path
        self._config = config if config is not None else None
        self._llm_profile_name = None
        self._llm_profile_data = None
        self._markdown_output = None
        # Add other attributes as needed for NebuchaShellzzar
        # ...

    # --- ADDED: Splash Screen ---
    def display_splash_screen(self, animated: bool = False):
        console = Console()
        if not animated:
            splash_text = """
[bold green]Wake up, Neo...[/]
[green]The Matrix has you...[/]
[bold green]Follow the white rabbit.[/]

Initializing NebulaShellzzar Crew...
            """
            panel = Panel(splash_text.strip(), title="[bold green]NebulaShellzzar[/]", border_style="green", expand=False)
            console.print(panel)
            console.print() # Add a blank line
        else:
            # Animated Matrix rain effect
            width = 60
            height = 12
            charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&"
            rain_cols = [0] * width
            with Live(refresh_per_second=20, console=console, transient=True) as live:
                for _ in range(30):
                    matrix = ""
                    for y in range(height):
                        line = ""
                        for x in range(width):
                            if random.random() < 0.02:
                                rain_cols[x] = 0
                            char = random.choice(charset) if rain_cols[x] < y else " "
                            line += f"[green]{char}[/]"
                        matrix += line + "\n"
                    panel = Panel(Text.from_markup(matrix), title="[bold green]NebulaShellzzar[/]", border_style="green", expand=False)
                    live.update(panel)
                    time.sleep(0.07)
            console.print("[bold green]Wake up, Neo...[/]")
            console.print("[green]The Matrix has you...[/]")
            console.print("[bold green]Follow the white rabbit.[/]")
            console.print("\nInitializing NebulaShellzzar Crew...\n")

    def _get_model_instance(self, profile_name: str) -> Model:
        """Gets or creates a Model instance for the given profile name."""
        if profile_name in self._model_instance_cache:
            logger.debug(f"Using cached Model instance for profile '{profile_name}'.")
            return self._model_instance_cache[profile_name]
        logger.debug(f"Creating new Model instance for profile '{profile_name}'.")

        # Fallback to simple OpenAI model if config not available
        try:
            profile_data = self.get_llm_profile(profile_name)
        except RuntimeError:
            # Config not loaded, use environment fallback
            import os

            from agents.models.openai_chatcompletions import OpenAIChatCompletionsModel
            from openai import AsyncOpenAI
            api_key = os.environ.get("OPENAI_API_KEY")
            if not api_key:
                raise ValueError("No OPENAI_API_KEY found and config not loaded")
            logger.warning(f"Config not available, using fallback OpenAI model for {profile_name}")
            client = AsyncOpenAI(api_key=api_key)
            model_instance = OpenAIChatCompletionsModel(model="gpt-3.5-turbo", openai_client=client)
            self._model_instance_cache[profile_name] = model_instance
            return model_instance
        if not profile_data:
             logger.critical(f"Cannot create Model instance: Profile '{profile_name}' (or default) not resolved.")
             raise ValueError(f"Missing LLM profile configuration for '{profile_name}' or 'default'.")
        profile_data.get("provider", "openai").lower()
        model_name = profile_data.get("model")
        if not model_name:
             logger.critical(f"LLM profile '{profile_name}' is missing the 'model' key.")
             raise ValueError(f"Missing 'model' key in LLM profile '{profile_name}'.")

        # Remove redundant client instantiation; rely on framework-level default client
        # All blueprints now use the default client set at framework init
        logger.debug(f"Instantiating OpenAIChatCompletionsModel(model='{model_name}') with default client.")
        try:
            model_instance = OpenAIChatCompletionsModel(model=model_name)
        except Exception as e:
             logger.error(f"Failed to instantiate OpenAIChatCompletionsModel for profile '{profile_name}': {e}", exc_info=True)
             raise ValueError(f"Failed to initialize LLM provider for profile '{profile_name}': {e}") from e
        self._model_instance_cache[profile_name] = model_instance
        return model_instance

    def create_starting_agent(self, mcp_servers: list[MCPServer]) -> Agent:
        """Creates the Matrix-themed agent team with Morpheus as the coordinator."""
        logger.debug(f"Creating NebulaShellzzar agent team with {len(mcp_servers)} MCP server(s)...") # Changed to DEBUG
        self._model_instance_cache = {}
        try:
            default_profile_name = self.config.get("llm_profile", "default")
        except RuntimeError:
            default_profile_name = "default"
            # Fallback if config not loaded
            default_profile_name = "default"
        default_model_instance = self._get_model_instance(default_profile_name)
        logger.debug(f"Using LLM profile '{default_profile_name}' for all agents.") # Changed to DEBUG

        neo = Agent(name="Neo", model=default_model_instance, instructions=neo_instructions, tools=[code_review, generate_documentation, execute_shell_command], mcp_servers=mcp_servers)
        trinity = Agent(name="Trinity", model=default_model_instance, instructions=trinity_instructions, tools=[execute_shell_command], mcp_servers=mcp_servers)
        Agent(name="Oracle", model=default_model_instance, instructions=oracle_instructions, tools=[])
        cypher = Agent(name="Cypher", model=default_model_instance, instructions=cypher_instructions, tools=[execute_shell_command])
        tank = Agent(name="Tank", model=default_model_instance, instructions=tank_instructions, tools=[execute_shell_command])

        morpheus = Agent(
             name="Morpheus", model=default_model_instance, instructions=morpheus_instructions,
             tools=[
                 execute_shell_command,
                 neo.as_tool(tool_name="Neo", tool_description="Delegate coding, review, or documentation tasks to Neo."),
                 trinity.as_tool(tool_name="Trinity", tool_description="Delegate information gathering or reconnaissance shell commands to Trinity."),
                 cypher.as_tool(tool_name="Cypher", tool_description="Delegate tasks to Cypher for alternative perspectives or direct shell execution if needed."),
                 tank.as_tool(tool_name="Tank", tool_description="Delegate specific shell command execution to Tank."),
             ],
             mcp_servers=mcp_servers
        )
        logger.debug("NebulaShellzzar agent team created. Morpheus is the starting agent.") # Changed to DEBUG
        return morpheus

    def render_prompt(self, template_name: str, context: dict) -> str:
        return f"User request: {context.get('user_request', '')}\nHistory: {context.get('history', '')}\nAvailable tools: {', '.join(context.get('available_tools', []))}"

    async def run(self, messages: list[dict], **kwargs):
        """Main execution entry point for the NebulaShellzzar blueprint."""
        logger.info("NebuchaShellzzarBlueprint run method called.")
        instruction = messages[-1].get("content", "") if messages else ""
        mcp_servers_override = kwargs.get("mcp_servers_override", [])
        from agents import Runner
        ux = BlueprintUXImproved(style="serious")
        try:
            # Runner.run() returns a final result, not an iterator
            result = await Runner.run(self.create_starting_agent(mcp_servers_override), instruction)
            # Wrap and yield the final result
            content = result["messages"][0]["content"] if result and isinstance(result, dict) and "messages" in result and result["messages"] else str(result)
            summary = ux.summary("Operation", 1, {"instruction": instruction[:40]})
            box = ux.ansi_emoji_box(
                title="NebulaShellzzar Result",
                content=content,
                summary=summary,
                params={"instruction": instruction[:40]},
                result_count=1,
                op_type="run",
                status="success"
            )
            yield {"messages": [{"role": "assistant", "content": box}]}
        except Exception as e:
            logger.error(f"Error during NebulaShellzzar run: {e}", exc_info=True)
            yield {"messages": [{"role": "assistant", "content": f"An error occurred: {e}"}]}

if __name__ == "__main__":
    import asyncio
    import json
    messages = [
        {"role": "user", "content": "Shell out to the stars."}
    ]
    blueprint = NebuchaShellzzarBlueprint(blueprint_id="demo-1")
    async def run_and_print():
        async for response in blueprint.run(messages):
            print(json.dumps(response, indent=2))
    asyncio.run(run_and_print())
