# Auto-generated by Swarm Team Wizard
import time
import uuid
from typing import Any

from swarm.core.blueprint_base import BlueprintBase


# Bind generic file/shell tools if requested by agents
class _Tool:
    def __init__(self, func, name):
        self.func = func
        self.name = name

def read_file(path: str) -> str:
    try:
        with open(path) as f:
            return f.read()
    except Exception as e:
        return "ERROR: " + str(e)
def write_file(path: str, content: str) -> str:
    try:
        with open(path, 'w') as f:
            f.write(content)
        return "OK: file written"
    except Exception as e:
        return "ERROR: " + str(e)
def list_files(directory: str = '.') -> str:
    import os
    try:
        return '\n'.join(os.listdir(directory))
    except Exception as e:
        return "ERROR: " + str(e)
def execute_shell_command(command: str) -> str:
    import os
    import subprocess
    try:
        timeout = int(os.getenv("SWARM_COMMAND_TIMEOUT", "60"))
        result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=timeout)
        output = "Exit Code: " + str(result.returncode) + "\n"
        if result.stdout:
            output += "STDOUT:\n" + result.stdout + "\n"
        if result.stderr:
            output += "STDERR:\n" + result.stderr + "\n"
        return output.strip()
    except subprocess.TimeoutExpired:
        return "Error: Command timed out after " + os.getenv('SWARM_COMMAND_TIMEOUT', '60') + " seconds."
    except Exception as e:
        return "Error executing command: " + str(e)
read_file_tool = _Tool(read_file, 'read_file')
write_file_tool = _Tool(write_file, 'write_file')
list_files_tool = _Tool(list_files, 'list_files')
execute_shell_command_tool = _Tool(execute_shell_command, 'execute_shell_command')

class PromptedTeamBlueprint(BlueprintBase):
    """
    Custom team blueprint created with the Swarm wizard.

    Agents:
        - Coordinator: orchestrates (tools: none)
        - Researcher: analysis (tools: list_files, read_file)
    """

    async def _original_run(self, messages: list[dict[str, Any]], **kwargs: Any):
        # Simple coordinator: echo last user message prefixed by team name
        last_user = next((m.get('content', '') for m in reversed(messages) if m.get('role') == 'user'), '')
        echo = "[" + "Prompted Team" + "] " + last_user
        completion_id = "chatcmpl-" + str(uuid.uuid4())
        created_ts = int(time.time())
        yield {
            "id": completion_id,
            "object": "chat.completion",
            "created": created_ts,
            "model": self.llm_profile_name or "default",
            "choices": [{
                "index": 0,
                "message": {"role": "assistant", "content": echo},
                "finish_reason": "stop",
                "logprobs": None
            }],
        }

    async def run(self, messages: list[dict[str, Any]], **kwargs: Any):
        async for result in self._original_run(messages, **kwargs):
            yield result

    def create_starting_agent(self, mcp_servers):
        # Example: attach per-agent tools based on the spec
        tools_map = {
            'Coordinator': [] if [] else [],
            'Researcher': [read_file_tool, list_files_tool] if [read_file_tool, list_files_tool] else [],
        }
        # Use the coordinator name if present, else fall back to first
        start_name = 'Coordinator'
        return self.make_agent(
            name=start_name,
            instructions="You are the coordinator for the team " + "Prompted Team" + ".",
            tools=tools_map.get(start_name, []),
            mcp_servers=mcp_servers,
        )


if __name__ == "__main__":
    import asyncio
    bp = PromptedTeamBlueprint(blueprint_id='prompted_team')
    async def _run():
        msgs = [{"role": "user", "content": "Say hello."}]
        last = None
        async for chunk in bp.run(msgs):
            try:
                if isinstance(chunk, dict) and chunk.get('choices'):
                    ch = chunk['choices'][0]
                    msg = ch.get('message') or {}
                    if isinstance(msg, dict) and 'content' in msg:
                        last = msg['content']
            except Exception:
                pass
        if last is not None:
            print(last)
    asyncio.run(_run())
