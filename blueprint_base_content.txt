"""
Swarm Blueprint Base Module (Sync Interactive Mode)
"""

import asyncio
import json
import logging
import os
import uuid
import sys
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List

from pathlib import Path
from swarm.core import Swarm
from swarm.extensions.config.config_loader import load_server_config
from swarm.settings import DEBUG
from swarm.utils.redact import redact_sensitive_data
from swarm.utils.context_utils import get_token_count
from swarm.extensions.blueprint.message_utils import (
    repair_message_payload,
    validate_message_sequence,
    truncate_preserve_pairs,
    truncate_strict_token,
    truncate_recent_only
)
from swarm.extensions.blueprint.agent_utils import (
    get_agent_name,
    discover_tools_for_agent,
    discover_resources_for_agent,
    initialize_agents
)
from swarm.extensions.blueprint.django_utils import register_django_components
from swarm.extensions.blueprint.spinner import Spinner
from swarm.extensions.blueprint.output_utils import pretty_print_response
from dotenv import load_dotenv
import argparse

logger = logging.getLogger(__name__)

# Optional import for NeMo Guardrails
try:
    from nemoguardrails import LLMRails, RailsConfig
except ImportError:
    LLMRails, RailsConfig = None, None

class BlueprintBase(ABC):
    """Base class for Swarm blueprints with sync interactive mode and Django integration."""

    def __init__(
        self,
        config: dict,
        auto_complete_task: bool = False,
        update_user_goal: bool = False,
        update_user_goal_frequency: int = 5,
        skip_django_registration: bool = False,
        record_chat: bool = False,
        log_file_path: Optional[str] = None,
        debug: bool = False,
        use_markdown: bool = False,
        **kwargs
    ):
        self.auto_complete_task = auto_complete_task
        self.update_user_goal = update_user_goal
        self.update_user_goal_frequency = max(1, update_user_goal_frequency)
        self.last_goal_update_count = 0
        self.record_chat = record_chat
        self.conversation_id = str(uuid.uuid4()) if record_chat else None
        self.log_file_path = log_file_path
        self.debug = debug or DEBUG
        self.use_markdown = use_markdown
        self._urls_registered = False

        if self.use_markdown:
            logger.debug("Markdown rendering enabled (if rich is available).")
        logger.debug(f"Initializing {self.__class__.__name__} with config: {redact_sensitive_data(config)}")
        if not hasattr(self, 'metadata') or not isinstance(self.metadata, dict):
            raise AssertionError(f"{self.__class__.__name__} must define a 'metadata' property returning a dictionary.")

        self.truncation_mode = self.metadata.get("truncation_mode", "preserve_pairs")
        self.max_context_tokens = max(1, self.metadata.get("max_context_tokens", 8000))
        self.max_context_messages = max(1, self.metadata.get("max_context_messages", 50))
        logger.debug(f"Truncation settings: mode={self.truncation_mode}, max_tokens={self.max_context_tokens}, max_messages={self.max_context_messages}")

        load_dotenv()
        logger.debug("Loaded environment variables from .env.")

        self.config = config
        self.skip_django_registration = skip_django_registration or not os.environ.get("DJANGO_SETTINGS_MODULE")
        self.swarm = kwargs.get('swarm_instance') or Swarm(config=self.config, debug=self.debug)
        logger.debug("Swarm instance initialized.")

        self.context_variables: Dict[str, Any] = {"user_goal": ""}
        self.starting_agent = None
        self._discovered_tools: Dict[str, List[Any]] = {}
        self._discovered_resources: Dict[str, List[Any]] = {}
        self.spinner = Spinner(interactive=not kwargs.get('non_interactive', False))

        required_env_vars = set(self.metadata.get('env_vars', []))
        missing_vars = [var for var in required_env_vars if not os.getenv(var)]
        if missing_vars:
            logger.warning(f"Missing environment variables for {self.metadata.get('title', self.__class__.__name__)}: {', '.join(missing_vars)}")

        self.required_mcp_servers = self.metadata.get('required_mcp_servers', [])
        logger.debug(f"Required MCP servers: {self.required_mcp_servers}")

        if self._is_create_agents_overridden():
            initialize_agents(self)
        register_django_components(self)

    def _is_create_agents_overridden(self) -> bool:
        """Check if create_agents is overridden in the subclass."""
        return self.create_agents.__qualname__.split('.')[0] != 'BlueprintBase'

    async def run_with_context_async(self, messages: List[Dict[str, Any]], stream: bool = False) -> Dict[str, Any]:
        """Run the blueprint with context asynchronously."""
        logger.debug("Running blueprint with context asynchronously.")
        try:
            response = await self.swarm.run(
                agent=self.determine_active_agent(),
                messages=messages,
                context_variables=self.context_variables,
                stream=stream
            )
            return {"response": response, "context_variables": self.context_variables}
        except Exception as e:
            logger.error(f"Error in run_with_context_async: {e}")
            return {"error": str(e)}

    def _pretty_print_response(self, messages: List[Dict[str, Any]]) -> None:
        """Delegate response printing to output_utils."""
        pretty_print_response(messages, use_markdown=self.use_markdown, spinner=self.spinner)

    @abstractmethod
    def create_agents(self) -> Dict[str, Agent]:
        """Abstract method to create agents for the blueprint."""
        pass

    @classmethod
    def main(cls):
        parser = argparse.ArgumentParser(description=f"Run the {cls.__name__} blueprint.")
        parser.add_argument("--config", default="./swarm_config.json", help="Path to the swarm_config.json file.")
        parser.add_argument("--instruction", help="Single instruction for non-interactive mode.")
        parser.add_argument("--stream", action="store_true", help="Enable streaming output in non-interactive mode.")
        parser.add_argument("--auto-complete-task", action="store_true", help="Enable task auto-completion in non-interactive mode.")
        parser.add_argument("--update-user-goal", action="store_true", help="Enable dynamic goal updates using LLM.")
        parser.add_argument("--update-user-goal-frequency", type=int, default=5, help="Frequency (in messages) for updating user goal.")
        parser.add_argument("--log-file-path", help="Path for logging output (default: ~/.swarm/logs/<blueprint_name>.log).")
        parser.add_argument("--debug", action="store_true", help="Enable debug logging to console instead of file.")
        parser.add_argument("--use-markdown", action="store_true", help="Enable markdown rendering for assistant responses.")
        args = parser.parse_args()

        root_logger = logging.getLogger()
        log_level = logging.DEBUG if args.debug or DEBUG else logging.INFO
        root_logger.setLevel(log_level)

        if root_logger.hasHandlers():
            root_logger.handlers.clear()

        log_formatter = logging.Formatter("[%(asctime)s] [%(levelname)s] %(name)s:%(lineno)d - %(message)s")
        log_handler = logging.StreamHandler(sys.stdout) if args.debug else logging.FileHandler(
            Path(args.log_file_path or Path.home() / ".swarm" / "logs" / f"{cls.__name__.lower()}.log").resolve(), mode='a'
        )
        log_handler.setFormatter(log_formatter)
        root_logger.addHandler(log_handler)
        logger.info(f"Logging initialized. Level: {logging.getLevelName(log_level)}. Destination: {getattr(log_handler, 'baseFilename', 'console')}")

        original_stderr = sys.stderr
        dev_null = None
        if not args.debug:
            try:
                dev_null = open(os.devnull, "w")
                sys.stderr = dev_null
                logger.info(f"Redirected stderr to {os.devnull}")
            except OSError as e:
                logger.warning(f"Could not redirect stderr: {e}")

        try:
            config_data = load_server_config(args.config)
            blueprint_instance = cls(
                config=config_data,
                auto_complete_task=args.auto_complete_task,
                update_user_goal=args.update_user_goal,
                update_user_goal_frequency=args.update_user_goal_frequency,
                log_file_path=str(getattr(log_handler, 'baseFilename', None)),
                debug=args.debug,
                use_markdown=args.use_markdown,
                non_interactive=bool(args.instruction)
            )
            if args.instruction:
                asyncio.run(blueprint_instance.non_interactive_mode_async(args.instruction, stream=args.stream))
            else:
                blueprint_instance.interactive_mode(stream=args.stream)
        except Exception as e:
            logger.critical(f"Blueprint execution failed: {e}", exc_info=True)
            print(f"Critical Error: {e}", file=original_stderr)
        finally:
            if not args.debug and dev_null is not None:
                sys.stderr = original_stderr
                dev_null.close()
                logger.debug("Restored stderr.")
            logger.info("Blueprint execution finished.")

if __name__ == "__main__":
    BlueprintBase.main()
